<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.81.0" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><title>Binary Trees&nbsp;&ndash;&nbsp;Just blog</title><link rel="stylesheet" href="/css/core.min.3df786ad920955310ebbd8e15789a2ec2e652cbb07ab77a151b075edae94015e92a8517831afbb42ab33ad99744d7e34.css" integrity="sha384-PfeGrZIJVTEOu9jhV4mi7C5lLLsHq3ehUbB17a6UAV6SqFF4Ma&#43;7QqszrZl0TX40"><meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Binary Trees" /><body><section id="header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/"><span class="site name">Just blog</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/tags/">Tags</a><a class="nav item" href="/posts">Posts</a><a class="nav item" href="/ds">Data structures</a><a class="nav item" href="/oop">OOP</a><a class="nav item" href="/solid">SOLID</a><a class="nav item" href="/algorithms">Algorithms</a><a class="nav item" href="/patterns">Design patterns</a><a class="nav item" href="/hash-table">Hash table</a><a class="nav item" href="/graphs">Graphs</a><a class="nav item" href="/trees">Trees</a></nav></div></span></div></section><section id="content"><div class="article-container"><section class="article header">
    <h1 class="article title">Binary Trees</h1><p class="article date">2021-06-02</p></section><article class="article markdown-body"><p>One of my favourite data structure.</p>
<h4 id="what-is-binary-search-tree">What is [Binary (Search)] Tree?</h4>
<p>A <em>tree</em> is an undirected graph which satisfies any of the following:</p>
<ul>
<li>an acyclic (i.e no cycles) connected graph</li>
<li>a connected graph with N nodes and N-1 edges.</li>
<li>an graph in which any two vertices are connected by exactly one path.</li>
</ul>
<p>Root node =&gt; top most node</p>
<p>If we have a rooted tree then we will want to have a reference to the root node of our tree.</p>
<p>Child node =&gt; node that extends from another node.</p>
<p>Parent node =&gt; is the inverse of child node.</p>
<p>Leaf node =&gt; node without no children</p>
<p>Subtree is a tree entirely containt within another tree.</p>
<pre><code>root	 				4 
	   		  		  / | \
parent of 7 and 2  	 0  3  9
    	   		   / |
child / leaf	  7  2

</code></pre><h4 id="what-is-binary-tree">What is Binary tree?</h4>
<p>A Binary Tree (BT) is a tree for which every node has <em>at most two child nodes</em>.</p>
<h4 id="what-is-binary-search-tree-1">What is Binary Search tree?</h4>
<p>A Binary Search Tree (BST) is a binary tree that satisfies the BST invariant:</p>
<ul>
<li>left subtree has smaller elements.</li>
<li>right subtree has larger elements.</li>
</ul>
<pre><code>Example of BST

			8 
		   / \
		  6   9
		 / \   \
		2   7   11
</code></pre><h4 id="when-and-where-to-use-it">When and where to use it?</h4>
<ul>
<li>Syntax trees - used by compiler and calcualtors</li>
<li>Used in the implementation of binary heaps</li>
<li>Treap - a probabilistic data structure (uses randomized BST).</li>
<li>Base of other trees.</li>
</ul>
<h4 id="complexity-of-bst">Complexity of BST</h4>
<table>
<thead>
<tr>
<th>Method</th>
<th>Average</th>
<th>Worst</th>
</tr>
</thead>
<tbody>
<tr>
<td>insert</td>
<td>O(log(n))</td>
<td>O(n)</td>
</tr>
<tr>
<td>delete</td>
<td>O(log(n))</td>
<td>O(n)</td>
</tr>
<tr>
<td>remove</td>
<td>O(log(n))</td>
<td>O(n)</td>
</tr>
<tr>
<td>search</td>
<td>O(log(n))</td>
<td>O(n)</td>
</tr>
</tbody>
</table>
<p>Cool, eh? And very useful!</p>
<p>If the tree is well structured, it is very good data strcuture and easy to implement. Most of the cases, worst case is not an option.</p>
<p>Worst case comes into play when the data creates a flat line &lsquo;tree&rsquo; and somehow you need to go through all the way to the last element.</p>
<p>You can think average case as a case where everytime you cut your search into half.</p>
<h4 id="implementation">Implementation</h4>
<p>How to implement a tree as BST?</p>
<ul>
<li>make sure that the elements are comparable so that we can order them inside the tree.</li>
</ul>
<p>When insterting an element we want to compare its value to the value stored in the current node we&rsquo;re considering to decide on one of the following:</p>
<ul>
<li>recurse down left subtree ( &lt; case )</li>
<li>recurese down right subtree ( &gt; case )</li>
<li>handle finding a duplicate value ( = case )</li>
<li>create a new node ( <em>null</em> case )</li>
</ul>
<pre><code>1. insert 7
		
		7

2. insert 20.
		
		7 
	   	  \ 
	   	   20

3. insert 5. 
		
		7 
	   / \ 
	  5   20

4. insert 15.

		7 
	   / \ 
	  5   20
	     / 
	    15

5. insert 10
		
		7 
	   / \ 
	  5   20
	     / 
	    15
	   /
	  10
</code></pre><p>Linear cases are covered with balanced binary search trees.</p>
<p>Removing elements from a BST can be seen as a two step process.</p>
<ol>
<li>find the element we wish to remove (if exists)</li>
<li>replace the node we want to remove with its successor to maintain the BST invariant.</li>
</ol>
<p>Remember:
BST invariant is where left subtree has smaller element and right subtree has larger elements.</p>
<h4 id="finding-phase">Finding phase</h4>
<p>When searching BST for a node with a particular value one of four things will happen:</p>
<ol>
<li>we hit null node at which point we know the value does not exist</li>
<li>comparator value equal to 0, (found it)</li>
<li>comparator value less than 0 (in left subtree)</li>
<li>comparator value greater than 0 (in right subtree)</li>
</ol>
<h4 id="remove-phase">Remove phase</h4>
<p>Removing has basically 4 cases:</p>
<ol>
<li>Node to remove is a leaf node</li>
<li>Node to remove has a right subtree but no left subtree</li>
<li>Node to remove has a left subtree but no right subtree</li>
<li>Node to remove has both a left and right subtree</li>
</ol>
<h5 id="handle-each-case-separately">Handle each case separately.</h5>
<p><em>Case I: Leaf node</em></p>
<p>If the node we wish to remove is a leaf node then we may do so without side effect.</p>
<pre><code>		8
	   / \
	  5   12
	 / \ 
	3   6

If we just remove 3, then we find it inside the tree and remove it. 
It will cause no side effects.

Result:

		8
	   / \
	  5   12
	   \ 
        6
</code></pre><p><em>Case II and III: left or right node has a subtree</em></p>
<p>This may be the case that we are trying to remove the root node of the (sub)tree in which case its immediate child becomes the new root.
This is the case where node has either left or right subtree.</p>
<pre><code>Suppose we want to remove 9
		5
	   / \
	  4   9
	     /  
 		7 
 	   / \
 	  6   8

First, we find the node 9.
Then remove it.
After that 7 will take its place.

Result:
		5
	   / \
	  4   7
	     / \
 		6   8
</code></pre><p><em>Case IV: node to remove has both a left and right subtree</em></p>
<p>In this case we have a problem - which node will take removable nodes place?</p>
<p>There are two options:</p>
<ol>
<li>largest value in the left subtree OR</li>
<li>smallest value in the right subtree</li>
</ol>
<p>This way the BST will satisfy the BST invariants.</p>
<pre><code>Remove 9

		5
	   / \
	  4   9
	     / \ 
 		7   11
 	   / \    \
 	  6   8    13

1. find 9 (if we have it)
2. now pick which option to go: 
	- largest from left subtree or
	- smallest form right subtree.
In this case we will go with the largest value.
3. find the largest value from the left subtree.
In our case it will be 8. Go as fas as possible.
4. copy that value from the node found in the subtree to the node we want to remove. 

		5
	   / \
	  4   8
	     / \ 
 		7   11
 	   / \    \
 	  6   8    13

5. Now is the case where we have double 8 in our tree.
But in this case we will have I or II or III case removal.

Result:

		5
	   / \
	  4   8
	     / \ 
 		7   11
 	   /      \
 	  6        13

</code></pre><h4 id="tree-traversals">Tree traversals</h4>
<ul>
<li>
<p>Preorder - prints before the recursive calls. This is basically from largest to smallest.</p>
</li>
<li>
<p>Inorder - prints between recursive calls. This is basically from smallest to largest.</p>
</li>
<li>
<p>Postorder - prints after recursive calls. This works through the subtree and then moves on.</p>
</li>
<li>
<p>Level order - in a level order traversal we want to print the nodes as they appear one layer at a time.</p>
</li>
</ul>
<pre><code>		5
	   / \
	  4   8
	     / \ 
 		7   11
 	   /      \
 	  6        13

In level order case we print:
5 - 4 - 8 - 7 - 11 - 6 - 13
</code></pre><p>First tree traversals are naturally defined recursively.</p>
<h4 id="source-code">Source code</h4>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#000;font-weight:bold">public</span> <span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">BinarySearchTree</span><span style="color:#000;font-weight:bold">&lt;</span>T <span style="color:#000;font-weight:bold">extends</span> Comparable<span style="color:#000;font-weight:bold">&lt;</span>T<span style="color:#000;font-weight:bold">&gt;&gt;</span> <span style="color:#000;font-weight:bold">{</span>

<span style="color:#000;font-weight:bold">}</span> 
</code></pre></div><h4 id="conclusion">Conclusion</h4>
</article><section class="article labels"><a class="tag" href=/tags/ds/>ds</a></section>
</div>
<div class="article bottom"><section class="article navigation"><p><a class="link" href="/ds/queue/"><span class="iconfont icon-article"></span>Queue</a></p></section></div></section><section id="footer"><div class="footer-wrap">
    <p class="copyright">Just blog</p>
    <p class="powerby"><span>Powered&nbsp;by&nbsp;</span><a href="https://gohugo.io" 
        target="_blank" rel="noopener noreferrer">Hugo</a><span>&nbsp;&amp;&nbsp;</span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank" rel="noopener noreferrer">Notepadium</a></p></div>
</section></body>

</html>